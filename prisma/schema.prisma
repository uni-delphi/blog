// schema.prisma

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
  //url       = env("POSTGRES_PRISMA_URL") // uses connection pooling
  //directUrl = env("POSTGRES_URL_NON_POOLING") // uses a direct connection
}

// Modelo para representar una encuesta
model Survey {
  id            Int           @id @default(autoincrement())
  title         String
  description   String?
  createdBy     User          @relation(fields: [createdById], references: [id])
  createdById   String
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt
  tecnologias   Tecnologias[]
  responseCount Int           @default(0) // New field to track the number of responses
  isActive      Boolean       @default(true)
  hasEnded      Boolean       @default(false)
  endDate       DateTime
}

model Tecnologias {
  id          Int          @id @default(autoincrement())
  title       String
  description String
  slug        String?      @unique
  enunciados  Enunciados[]
  survey      Survey       @relation(fields: [surveyId], references: [id])
  surveyId    Int
  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt
}

model Enunciados {
  id                   Int                    @id @default(autoincrement())
  title                String
  description          String
  slug                 String?                @unique
  questionsEnunciados  QuestionEnunciado[] // Relación many-to-many con Question
  tecnologia           Tecnologias            @relation(fields: [tecnologiaId], references: [id])
  tecnologiaId         Int
  questions            Question[]
  response             Response[]
  createdAt            DateTime               @default(now())
  updatedAt            DateTime               @updatedAt
  SingleChoiceResponse SingleChoiceResponse[]
  CheckboxResponse     CheckboxResponse?
}

// Tabla intermedia para la relación many-to-many entre Question y Enunciado
model QuestionEnunciado {
  enunciado   Enunciados @relation(fields: [enunciadoId], references: [id])
  enunciadoId Int

  question   Question @relation(fields: [questionId], references: [id])
  questionId Int

  @@id([enunciadoId, questionId])
}

// Modelo para representar una pregunta
model Question {
  id                    Int                    @id @default(autoincrement())
  text                  String
  type                  QuestionType
  inputType             InputQuestionType?
  additionalInfo        String?
  enunciados            Enunciados[] // Relación many-to-many con Enunciados
  createdAt             DateTime               @default(now())
  updatedAt             DateTime               @updatedAt
  responses             Response[]
  singleChoiceResponses SingleChoiceResponse[]
  checkboxResponses     CheckboxResponse[]
  questionEnunciados    QuestionEnunciado[] // Relación inversa con QuestionEnunciado
}

// Enum para definir los tipos de preguntas posibles
enum QuestionType {
  CHECKBOX
  SINGLE_CHOICE
}

enum InputQuestionType {
  NIVEL
  IMPORTANCIA
  DIFUSION
  ACELERAN
  FRENAN
  IMPACTO
  DIFUSION_2024
  DIFUSION_2027
  DIFUSION_2030
}

// Modelo para representar una respuesta a una pregunta
model Response {
  id             Int                   @id @default(autoincrement())
  respondent     User                  @relation(fields: [respondentId], references: [id])
  respondentId   String
  question       Question?             @relation(fields: [questionId], references: [id])
  questionId     Int?
  enunciados     Enunciados            @relation(fields: [enunciadosId], references: [id])
  enunciadosId   Int
  answer         String // You may adjust this based on the type of answers expected
  responseType   ResponseType // New field to specify the type of response
  singleChoice   SingleChoiceResponse?
  singleChoiceId Int?
  checkbox       CheckboxResponse?
  checkboxId     Int?
  createdAt      DateTime              @default(now())
  updatedAt      DateTime              @updatedAt
}

// Enum to define the types of responses
enum ResponseType {
  SINGLE_CHOICE
  CHECKBOX
}

// Modelo para representar una respuesta a una pregunta de opción única (radio button)
model SingleChoiceResponse {
  id           Int         @id @default(autoincrement())
  question     Question    @relation(fields: [questionId], references: [id])
  questionId   Int
  choice       String
  createdAt    DateTime    @default(now())
  answer       String
  response     Response?   @relation(fields: [responseId], references: [id])
  responseId   Int?        @unique
  enunciados   Enunciados? @relation(fields: [enunciadosId], references: [id])
  enunciadosId Int?        @unique
}

// Modelo para representar una respuesta a una pregunta de selección múltiple (checkbox)
model CheckboxResponse {
  id           Int         @id @default(autoincrement())
  question     Question    @relation(fields: [questionId], references: [id])
  questionId   Int
  choices      String[]
  createdAt    DateTime    @default(now())
  answer       String
  response     Response?   @relation(fields: [responseId], references: [id])
  responseId   Int?        @unique
  enunciados   Enunciados? @relation(fields: [enunciadosId], references: [id])
  enunciadosId Int?        @unique
}

model User {
  id                 String               @id @default(cuid())
  name               String?
  lastName           String?
  email              String               @unique
  country            String
  state              String
  education          String
  sector             String
  institution        String
  expertees          String
  years              String
  password           String
  createdat          DateTime             @default(now())
  updatedAt          DateTime             @updatedAt
  role               RoleType             @default(USER)
  accounts           Account[]
  sessions           Session[]
  createdSurveys     Survey[] // Relación inversa para las encuestas creadas por el administrador
  responses          Response[] // Add this line to establish the relation with responses
  passwordReserToken PasswordReserToken[]
  //singleChoiceResponses SingleChoiceResponse[] // Add this line to establish the relation with single choice responses
  //checkboxResponses     CheckboxResponse[] // Add this line to establish the relation with checkbox responses
}

model PasswordReserToken {
  id        Int       @id @default(autoincrement())
  token     String    @unique
  createdAt DateTime  @default(now())
  resetAt   DateTime?
  user      User      @relation(fields: [userId], references: [id])
  userId    String
}

enum RoleType {
  ADMIN
  USER
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  id         Int      @id @default(autoincrement())
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}
